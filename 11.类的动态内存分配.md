## 11.类的动态内存分配

1. ![image-20201218184809497](assets/image-20201218184809497.png)

2. 不能在类声明中初始化静态成员变量。因为声明描述了如何分配内存，但并不分配内存。对于静态的类成员可以在类声明之外使用单独的语句进行初始化：

   ```cpp
   // str.h
   class Str {
       char *str;
       int len;
   public:
     	// 静态类变量
       static int num_strs;
   };
   
   // str.cpp
   // 初始化类中的静态成员变量 (开头的int是必须加的，直接写`Str::num_strs = 10`会报错)
   int Str::num_strs = 10;
   
   // main.cpp调用
   		Str s;
       cout << s.num_strs << endl;				// 输出：10
       cout << Str::num_strs << endl;		// 输出：10
       s.num_strs++;
       cout << Str::num_strs << endl;		// 输出：11
   ```

   初始化类的静态变量需要在方法文件(.cpp)中，而不是在类声明的文件(.h)中。这是因为类声明位于头文件中，程序可能将头文件包含在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本从而引发错误。

   但是，如果类的静态成员变量是**整形的const**或**枚举型**，则可以在类声明中初始化。

   ```cpp
   class Str {
       char *str;
       int len;
   public:
     	// static const int 是可以直接在类声明里赋值的
       static const int num_strs = 1024;
     	// 枚举型可以在类声明中直接赋值
     	enum {
           Red = 100, Blue = 200, Yellow = 300
       };
   };
   
   // main.cpp
       cout << Str::num_strs << endl;		// 输出：1024
       cout << Str::Red << endl;					// 输出：100
       cout << Str::Blue << endl;				// 输出：200
       cout << Str::Yellow << endl;			// 输出：300
   ```

3. std::strlen()函数的参数需要是一个`const char *`，该函数将计算字符串的长度（真正的字符数量，不包含末尾的空字符）。复制一个字符串副本：

   ```cpp
   		len = strlen(chs);
       str = new char[len + 1];
       strcpy(str, chs);
   ```

4. 关于在构造函数中使用new来在堆内存中分配内存空间：

   ![image-20201220113320171](assets/image-20201220113320171.png)

5. 关于构造函数的调用问题：假设有以下类：

   ```cpp
   // str.h
   class Str {
       char *str;
       int len;
   public:
       Str();
   
       Str(const char *);
   
       Str(const Str &);
   
       ~Str();
   };
   // str.cpp
   Str::Str(const char *chs) {
       len = strlen(chs);
       str = new char[len + 1];
       strcpy(str, chs);
       cout << "Str::Str(const char *chs)" << endl;
   }
   
   Str::Str() {
       len = 0;
       cout << "Str::Str()" << endl;
   }
   
   Str::Str(const Str &s) {
       len = s.len;
       str = new char[len + 1];
       strcpy(str, s.str);
       cout << "Str::Str(const Str &s)" << endl;
   }
   
   Str::~Str() {}
   
   // 调用
   			// 调用构造函数Str::Str(const char *chs)
   			Str s("michael.w");		// 输出：Str::Str(const char *chs)
   			// 重点！调用构造函数Str::Str(const Str &s)
   			Str s1 = s;						// 输出：Str::Str(const Str &s)
   ```

   当对象作为值传递时，会在传参时生成副本。这个副本的生成默认调用参数为**该类对象引用的**构造函数：

   ```cpp
   // main.cpp中，有方法
   void func(Str& s) {
       cout << "func" << endl;
   }
   
   // main函数中：
       Str s("michael.w");
   		// 在func函数调用的过程中，会创建s对象的副本。该处将默认调用Str的构造方法Str::Str(const Str &s) 
       func(s);
   ```

   结论：当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为**复制构造函数**，因为它创建对象的一个副本）。

6. 具体的说，c++为一个类**自动提供**下面这些成员函数：

   ![image-20201220155851145](assets/image-20201220155851145.png)

   **1.默认构造函数**：

   ![image-20201220165629605](assets/image-20201220165629605.png)

   ```cpp
   // 显式定义默认构造函数
   Klunk::Klunk(){
     	klunk_ct = 0;
   }
   ```

   ![image-20201220165831609](assets/image-20201220165831609.png)

   **2.复制构造函数**

   ![image-20201220170104794](assets/image-20201220170104794.png)

   关于复制构造函数需要知道两点：1.何时调用？2.有何功能？

   何时调用复制构造函数？

   ![image-20201220173631973](assets/image-20201220173631973.png)

   由于按值传递对象将调用复制构造函数，因此应该**按引用传递对象**。这样可以节省调用构造函数的时间以及存储对象的空间。

   默认的复制构造函数是如何复制对象的？

   默认的复制构造函数逐个复制**非静态成员**（成员复制也称为浅复制），复制的是成员的值。例如下述语句：

   ```cpp
   StringBad sailor = sports;
   ```

   与下面的代码等效（由于私有成员无法访问，因此下面代码不能通过编译）：

   ```cpp
   StringBad sailor;
   sailor.str = sports.str;
   sailor.len = sports.len;
   ```

   如果成员本身就是类对象，则将使用该类的复制构造函数来复制成员对象。**静态类变量**不受影响，因为它们属于整个类，而不是各个对象。

   注：如果类中包含这样的**静态数据成员**，其值在该类的新对象被创建时发生会发生变化，则应该提供一个显式复制构造函数来处理该静态数据成员的计数问题。如果不显式提供，则在系统默认调用复制构造函数（当形参创建副本）时，没有将该静态数据成员自增，而在析构函数中会将静态成员自减（程序员已显式定义析构函数）。

7. 如果一个类的成员是char *（使用new初始化的并且指向数据的指针），而不是数据本身。在调用复制构造函数时（比如函数参数值传递），会将该成员进行浅复制。这样，当这个副本被析构时（函数结束后），会将该指针成员指向的内存也释放掉，而原来的类对象中的指针将指向一个已被释放的空间，十分危险。

   ![image-20201220180029438](assets/image-20201220180029438.png)

8. 接6：

   **3.赋值运算符**
