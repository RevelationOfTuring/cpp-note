## 12.类继承

1. ![image-20201222131517090](assets/image-20201222131517090.png)![image-20201222131650831](assets/image-20201222131650831.png)

2. 从一个类派生出另一个类时，原始类成为基类，继承类称为派生类。

3. 写一个基类：

   ```cpp
   // table_tennis_player.h
   
   #include<string>
   
   using namespace std;
   
   class TableTennisPlayer {
       string first_name;
       string last_name;
       bool has_t;
   public:
       TableTennisPlayer(const string &first_name = "none", const string &last_name = "none", bool has_table = false);
   
       void name() const;
   
       bool has_table() const { return has_t; };
   
       void reset_table(bool b) { has_t = b; }
   };
   
   // table_tennis_player.cpp
   #include<iostream>
   
   TableTennisPlayer::TableTennisPlayer(const string &first_name, const string &last_name, bool has_table) {
       this->first_name = first_name;
       this->last_name = last_name;
       this->has_t = has_table;
   }
   
   void TableTennisPlayer::name() const {
       std::cout << last_name << ", " << first_name << endl;
   }
   ```

   派生一个类：

   ```cpp
   // rated_player.h
   class RatedPlayer : public TableTennisPlayer {
   		...
   };
   ```

   TableTennisPlayer被声明为一个公有基类，这被称为公有派生。派生类对象包含基类对象。使用公有派生，**基类的公有成员将成为派生类的公有成员**；基类的私有部分也将成为派生类的一部分，但是只能通过基类的**公有和保护方法**访问。

   ![image-20201222134140754](assets/image-20201222134140754.png)

   继承特性中需要增添什么？

   - 派生类需要自己的构造函数；
   - 派生类可以根据需要增添额外的数据成员和成员函数。

   ```cpp
   // rated_player.h
   class RatedPlayer : public TableTennisPlayer {
       unsigned int rating;
   public:
       RatedPlayer(unsigned int r = 0, const string &fn = "none", const string &ln = "none", bool ht = false);
   
       RatedPlayer(unsigned int r, const TableTennisPlayer &ttp);
   
       // 新增添的类函数
       unsigned int get_rating() const { return rating; }
   
       void reset_rating(unsigned int r) { rating = r; }
   };
   
   // rated_player.cpp
   
   // `TableTennisPlayer(fn, ln, ht)`为成员初始化列表，其调用TableTennisPlayer构造函数
   RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &ln, bool ht) : TableTennisPlayer(fn, ln, ht) {
       rating = r;
   }
   
   RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &ttp) : TableTennisPlayer(ttp) {
       rating = r;
   }
   ```

   RatePlayer构造函数不能直接设置继承的成员（first_name、last_name和has_t），必须使用基类的公有方法来访问私有的基类成员。具体的说，**派生类构造函数必须使用基类构造函数**。

   ```cpp
   // 如果省略成员初始化列表`TableTennisPlayer(fn, ln, ht)`，即
   RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &ln, bool ht)  {
       rating = r;
   }
   
   // 程序将使用默认的基类构造函数，即等价于
   RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &ln, bool ht) : TableTennisPlayer() {	// 该出隐式调用了基类的复制构造函数（如果基类中没有定义复制构造函数，那么编译器将自动生成一个）
       rating = r;
   }
   ```

   ![image-20201222150308178](assets/image-20201222150308178.png)![image-20201222150548084](assets/image-20201222150548084.png)

4. 

