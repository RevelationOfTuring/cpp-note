## 12.类继承

1. ![image-20201222131517090](assets/image-20201222131517090.png)![image-20201222131650831](assets/image-20201222131650831.png)

2. 从一个类派生出另一个类时，原始类成为基类，继承类称为派生类。

3. 写一个基类：

   ```cpp
   // table_tennis_player.h
   
   #include<string>
   
   using namespace std;
   
   class TableTennisPlayer {
       string first_name;
       string last_name;
       bool has_t;
   public:
       TableTennisPlayer(const string &first_name = "none", const string &last_name = "none", bool has_table = false);
   
       void name() const;
   
       bool has_table() const { return has_t; };
   
       void reset_table(bool b) { has_t = b; }
   };
   
   // table_tennis_player.cpp
   #include<iostream>
   
   TableTennisPlayer::TableTennisPlayer(const string &first_name, const string &last_name, bool has_table) {
       this->first_name = first_name;
       this->last_name = last_name;
       this->has_t = has_table;
   }
   
   void TableTennisPlayer::name() const {
       std::cout << last_name << ", " << first_name << endl;
   }
   ```

   派生一个类：

   ```cpp
   // rated_player.h
   class RatedPlayer : public TableTennisPlayer {
   		...
   };
   ```

   TableTennisPlayer被声明为一个公有基类，这被称为公有派生。派生类对象包含基类对象。使用公有派生，**基类的公有成员将成为派生类的公有成员**；基类的私有部分也将成为派生类的一部分，但是只能通过基类的**公有和保护方法**访问。

   ![image-20201222134140754](assets/image-20201222134140754.png)

   继承特性中需要增添什么？

   - 派生类需要自己的构造函数；
   - 派生类可以根据需要增添额外的数据成员和成员函数。

   ```cpp
   // rated_player.h
   class RatedPlayer : public TableTennisPlayer {
       unsigned int rating;
   public:
       RatedPlayer(unsigned int r = 0, const string &fn = "none", const string &ln = "none", bool ht = false);
   
       RatedPlayer(unsigned int r, const TableTennisPlayer &ttp);
   
       // 新增添的类函数
       unsigned int get_rating() const { return rating; }
   
       void reset_rating(unsigned int r) { rating = r; }
   };
   
   // rated_player.cpp
   
   // `TableTennisPlayer(fn, ln, ht)`为成员初始化列表，其调用TableTennisPlayer构造函数
   RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &ln, bool ht) : TableTennisPlayer(fn, ln, ht) {
       rating = r;
   }
   
   RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer &ttp) : TableTennisPlayer(ttp) {
       rating = r;
   }
   ```

   RatePlayer构造函数不能直接设置继承的成员（first_name、last_name和has_t），必须使用基类的公有方法来访问私有的基类成员。具体的说，**派生类构造函数必须使用基类构造函数**。

   ```cpp
   // 如果省略成员初始化列表`TableTennisPlayer(fn, ln, ht)`，即
   RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &ln, bool ht)  {
       rating = r;
   }
   
   // 程序将使用默认的基类构造函数，即等价于
   RatedPlayer::RatedPlayer(unsigned int r, const string &fn, const string &ln, bool ht) : TableTennisPlayer() {	// 该出隐式调用了基类的复制构造函数（如果基类中没有定义复制构造函数，那么编译器将自动生成一个）
       rating = r;
   }
   ```

   ![image-20201222150308178](assets/image-20201222150308178.png)![image-20201222150548084](assets/image-20201222150548084.png)

4. 派生类和基类之间的特殊关系：

   - 派生类对象可以使用基类的方法（基类的非私有的方法）；
   - **基类指针**可以在不进行显式类型转换的情况下指向派生类对象；
   - **基类引用**可以在不进行显式类型转换的情况下引用派生类对象；

```cpp
TableTennisPlayer ttp("michael", "wang", false);
    RatedPlayer rp(1024, "Kobe", "Bryant", true);
    // 基类的引用引用派生类对象
    TableTennisPlayer &rttp = rp;
    // 基类的指针指向派生类对象
    TableTennisPlayer *pttp = &rp;
    rttp.name();		// 输出：Bryant, Kobe
    pttp->name();		// 输出：Bryant, Kobe
```

基类指针或引用只能用于调用基类方法，不能调用派生类方法。

![image-20201222222106328](assets/image-20201222222106328.png)

5. 看下面代码：

   ```cpp
   		RatedPlayer rp(1024, "Kobe", "Bryant", true);
   		// 要初始化ttp，匹配构造函数的原型：TableTennisPlayer(const RatedPlayer &);
   		// 但是由于没有在类声明中定义这样的构造函数，会被隐式调用构造函数TableTennisPlayer(const TableTennisPlayer &);
   		TableTennisPlayer ttp(rp);	// 形参是基类引用可以引用派生类
       ttp.name();
   ```

   `TableTennisPlayer ttp(rp)`将ttp初始化成**嵌套在RatedPlayer对象rp中的TableTennisPlayer对象**。

6. 两种重要的机制可用于实现多态公有继承：1.在派生类中重新定义基类的方法；2.使用虚方法。

7. 什么是虚方法？看下面的例子：

   ```cpp
   
   ```

   

   

8. 

9. 

10. 

11. c++有3种继承方式：公有继承、保护继承和私有继承。

     