## 8. 内存模型和名称空间

1. 单独编译：![image-20201207101214994](assets/image-20201207101214994.png)

2. 如果多个文件都使用了同一种struct，那是要在每一个文件中都复制一份struct的声明么？![image-20201207101531160](assets/image-20201207101531160.png)![image-20201207101846228](assets/image-20201207101846228.png)

3. 请不要将**函数定义**或**变量声明**放到头文件中！如果头文件包含一个函数的定义，然后在其他两个文件（属于同一个程序）中包含该头文件，则同一个程序中将包含同一个函数的两个定义。除非函数是内联的，否则将出错。

4. 头文件中常包含：

   ![image-20201207103351110](assets/image-20201207103351110.png)

5. 关于头文件的包含方式：

   ![image-20201207103447321](assets/image-20201207103447321.png)

6. 头文件举例：

   头文件`coordin.h`：

   ```cpp
   #ifndef COORDIN_H_
   #define COORDIN_H_
   
   struct polar {
       double distance;
       double angle;
   };
   
   struct rect {
       double x;
       double y;
   };
   
   polar rect_to_polar(rect xypos);
   
   void show_polar(polar dapos);
   
   #endif
   ```

   源代码文件`coordin.cpp`：

   ```cpp
   #include "coordin.h"
   #include <cmath>
   #include <iostream>
   
   using namespace std;
   
   // 定义coordin.h中声明的函数
   polar rect_to_polar(rect xypos) {
       polar answer;
       answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
       answer.angle = atan2(xypos.y, xypos.x);
       return answer;
   }
   
   void show_polar(polar dapos) {
       const double Rad_to_deg = 57.29577951;
       cout << "distance = " << dapos.distance;
       cout << ", angle = " << dapos.angle * Rad_to_deg << " degrees" << endl;
   }
   ```

   源代码文件main.cpp：

   ```cpp
   #include "coordin.h"
   
   int main() {
       rect rplace = rect{4, 3};
       polar pplace = rect_to_polar(rplace);
       show_polar(pplace);
   }
   
   // 输出：
   // distance = 5, angle = 36.8699 degrees
   ```

   注：一个.h头文件往往都配有一个同文件名的.cpp文件，来定义.h头文件中的函数原型。

7. cpp文件的编译流程：![image-20201207104525853](assets/image-20201207104525853.png)

8. 头文件管理：

   ![image-20201207104913339](assets/image-20201207104913339.png)![image-20201207105132189](assets/image-20201207105132189.png)

   通过#define定义一个同**头文件名相同的常量符号**就会为了让编译器快速得知该头文件在当前有没有被包含过，如果该变量已经被定义，说明该头文件已经被包含过了。

9. ![image-20201207111632971](assets/image-20201207111632971.png)

10. 多个库的链接

   ![image-20201207111817779](assets/image-20201207111817779.png)

11. c++使用三种（c++11中是四种）不同的方案来存储数据：

    ![image-20201207112102889](assets/image-20201207112102889.png)

12. 作用域（scope）：描述了名称在文件（单元）的多大范围内可见。例如：函数中定义的变量可在该函数中使用，但不能在其他函数中使用；在文件中的函数定义之前定义的变量则可在所有函数中使用。

13. 链接性（linkage）：描述了名称如何在不同单元间共享。链接性为**外部**的名称可在文件件共享，链接性为**内部**的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。

14. ![image-20201207113300652](assets/image-20201207113300652.png)

    如果同名，代码块内的变量名将屏蔽代码块外的变量名：

    ![image-20201207114705951](assets/image-20201207114705951.png)

15. 关于auto关键字：

    c++11中关键字auto用于自动类型推断。但在c语言和以前的c++版本中，auto的含义截然不同，它用于显式地指出变量为自动存储（即局部自动变量）:

    ```cpp
    		// c语言和以前的c++版本中
    		auto float ford;
        // 等价于
        float ford;
    ```

    因此程序员几乎不使用它。

16. ![image-20201207141330620](assets/image-20201207141330620.png)

    栈传递参数示意图：

    ![image-20201207150451915](assets/image-20201207150451915.png)

17. 寄存器变量：![image-20201207150705432](assets/image-20201207150705432.png)

18. 静态持续变量：![image-20201207150947098](assets/image-20201207150947098.png)

    如何创建三种不同链接性的静态持续变量：![image-20201207151243965](assets/image-20201207151243965.png)

    注：上述代码中的global、one_file和count在整个程序执行期间都存在。count在函数内部定义，无链接性，所以只能在funct1函数内部使用它。global和one_file作用域都是真个文件。由于one_file为内部链接性，因此只能在上述代码文件中使用它。而global（外部链接性）在其他程序文件中也可以使用。

    ![image-20201207151639757](assets/image-20201207151639757.png)
    
19. 静态变量的初始化：![image-20201207152252725](assets/image-20201207152252725.png)

    ```cpp
    #include <cmath>
    
    int x;                  // 零初始化
    int y = 5;              // 常量表达式初始化
    long z = 13 * 13;       // 常量表达式初始化
    const double pi = 4.0 * atan(1.0);  // 动态初始化
    ```

    初始化pi必须调用函数atan()，这需要等到该函数被链接并且程序执行时。

    ![image-20201207152741176](assets/image-20201207152741176.png)

    注：c++11新增了关键字`constexpr`，这增加了创建**常量表达式**的方式。这里不会相信介绍该特性。

20. ![image-20201207152953418](assets/image-20201207152953418.png)

    在每个使用外部变量的文件中，都必须声明它。由于c++要求每个变量只能由一次定义。为满足这种需求，c++提供了两种变量声明：

    - 定义声明（defining declaration）或简称为定义（definition）：它给变量分配存储空间；
    - 引用声明（referencing declaration）或简称为声明（declaration）：它不给变量分配存储空间。

    引用声明使用关键字**extern**，且不进行初始化：

    ```cpp
    double up;              // 定义，up的值为0（零值初始化）
    extern int blem;        // 声明，blem在别处被定义
    extern char gr = 'r';   // 定义
    ```

    ![image-20201207153702857](assets/image-20201207153702857.png)

    注：在file01.cpp中定义cats时的extern，是可以省略的。

21. 假设当函数中局部变量与外部变量同名：

    ```cpp
    int num = 1024;
    
    int main() {
        int num = 2048;	// 局部同名变量将屏蔽全局变量
        cout << num << endl;
      	// ::num表示全局版本的num变量。如果在局部变量名与全局变量名不发生冲突时（没有叫num的局部变量），num直接表示全局变量
        cout << ::num << endl;
    }
    ```

    c++比c语言更进一步——提供了作用域解析运算符`::`。放在变量名前面时，该运算符表示使用变量的全局版本。

22. 全局变量和局部变量的选择：![image-20201207160007122](assets/image-20201207160007122.png)

23. 如果文件定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中静态变量将隐藏常规外部变量：

    ```cpp
    // file1
    int i = 1;      // 外部变量定义
    
    // file2
    static int i = 5;		// 在file2中，将只能看见该静态外部变量而看不到file1中的i
    void func(){
      cout << i; // 输出5
    }
    ```

    ![image-20201207204601119](assets/image-20201207204601119.png)

24. 可使用外部变量在**多个文件程序的不同部分**之间共享数据；可使用链接性为内部的静态变量在**同一个文件中的多个函数**之间共享数据（名称空间提供了另外一种共享数据的方法）。

25. 将static限定符用于代码块中定义变量，将导致局部变量的存储持续性为**静态**的。虽然该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。另外，如果初始化了静态局部变量，则程序只在启动时进行一次初始化。以后再调用函数时不会像自动变量那样再次被初始化：

    ```cpp
    void func(const char chs[]) {
      	// 静态局部变量。函数结束后，该变量仍然后存在。
        static int total;
        total += strlen(chs);
        cout << total << endl;
    }
    		func("abc");
        func("michael");
        func("z");
    		// 输出：
    		//	3
    		//  10
    		//	11
    ```

    所以静态局部变量total将记录所有传入过func函数的字符串长度之和。

26. cv-限定符

    - const
    - volatile

    最常用的cv-限定符就是const，表明内存被初始化后，程序便不能再对它进行修改。

    volatile表明即使代码没有对内存单元进行修改，其值也可能发生变化。例如：

    1.将一个指针指向某个硬件位置，其中包含了来自串行端口的时间或信息。这种情况下，硬件（而不是程序）可能修改其中的内容；

    2.两个程序可能相互影响共享数据。

    该关键字的作用是为了改善编译器的优化能力。例如假设编译器发现程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会改变。如果不将变量声明为volatile，则编译器将进行这种优化；将变量声明为volatile相当于告诉编译器不要进行这种优化。

27. mutable

    ![image-20201208103817220](assets/image-20201208103817220.png)

    ```cpp
    		const data d = {"michael", 20};
        strcpy(d.name, "aaa");	// 编译报错
        d.accesses++;	// 编译器允许
    ```

    d的const限定符禁止程序修改mutable，但accesses成员的mutable说明符使得accesses不受到这种限制。   

28. ![image-20201208105443184](assets/image-20201208105443184.png)

    ```cpp
    const int i = 10; // 等价于static const int i = 10;
    
    int main() {
    		......
    }
    ```

    ![image-20201208161403413](assets/image-20201208161403413.png)

29. 为什么const声明的链接性不能像常规变量那样是外部的呢？

    因为根据单定义规则，只能有一个文件可以包含前面的声明，而其他文件必须使用extern关键字来提供引用声明。另外，只有未使用extern关键字的声明才能进行初始化：

    ```cpp
    // 假设：使用别的文件定义“全局const变量”的声明
    extern const int i;
    ```

    所以各个文件要做的声明是不一样的。自己文件定义的“全局const变量”不要extern，别的文件定义的则需要。而如果const定义的链接性为内部时，所有文件中可以使用相同的声明。

    ![image-20201208163018059](assets/image-20201208163018059.png)

30. 如果出于某种原因，程序员希望某个常量的链接性为外部，则可以使用extern关键字来覆盖默认的内部链接性：

    ```cpp
    extern const int i = 1024;		// 定义为外部链接性
    ```

    ![image-20201208163826593](assets/image-20201208163826593.png)

31. 函数的链接性：

    ![image-20201208164056863](assets/image-20201208164056863.png)![image-20201208164206400](assets/image-20201208164206400.png)

    这意味该函数只在这个文件中可见，并且在别的文件中可以定义同名的函数。和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义。因此即使在外部定义了同名函数，该文件仍将使用静态函数。

32. ![image-20201208165926098](assets/image-20201208165926098.png)

33. c++在哪里查找函数？

    ![image-20201208170059998](assets/image-20201208170059998.png)

34. 语言链接性

    ![image-20201208170305808](assets/image-20201208170305808.png)

    链接程序寻找与c++函数调用匹配的函数与c语言不通。但是如果在c++程序中使用c库中预编译的函数可能会出现一些问题：

    ```cpp
    spiff(22); // 在c++调用c库中的spiff(int)函数
    ```

    spiff在c库文件中的符号名称为`_spiff`。但是对于c++程序而言，它在查找的符号名称为`_spiff_i`。为解决该问题，需要用函数原型来指出要使用的约定：

    ```cpp
    extern "C" void spiff(int); 	// 使用c语言链接性
    extern void spiff(int);     	// 使用c++语言链接性
    extern "C++" void spiff(int);	// 使用c++语言链接性
    ```

    第二个原型通过默认方式指出这一点，而第三个显式地指出这一点。

35. 前面介绍的c++用来为变量分配内存的5种方案（线程内存除外）并不适用于c++的运算符new（或c函数malloc()）分配的内存。这种内存被称为动态内存。由于动态内存是由运算符new和delete控制，而不是由作用域和链接性规则控制。因此可以在一个函数中分配动态内存，而在另一个函数中将其释放。与自动内存不同，动态内存不是LIFO（栈），其分配和释放要取决于new和delete在何时以何种方式被使用。

    通常，编译器使用3块独立内存：一块用于**静态变量**，一块用于**自动变量**，第三块用于**动态存储**。

    ![image-20201208172612263](assets/image-20201208172612263.png)

36. 如何使用new运算符初始化：![image-20201208173622991](assets/image-20201208173622991.png)

    在c++11中，还可以将**列表初始化**用于单值变量：

    ```cpp
    int *p_i = new int{6};		// *p_i 为 6
    double *p_d = new double{1.1};	// *p_d 为 1.1
    ```

37. new失败时：

    ![image-20201208173926038](assets/image-20201208173926038.png)

38. new和delete的执行：

    ![image-20201208180811141](assets/image-20201208180811141.png)![image-20201208181124084](assets/image-20201208181124084.png)

    c++将这些函数成为**可替换的**（replaceable）。这意味着如果你有足够的知识和意愿，可为new和delete提供替换函数，并根据需求对其进行定制。比如：可定义作用域为类的替换函数并对其进行定制以满足该类的内存分配需求。在代码中仍将使用new运算符，但它将调用你自己定义的new()函数。

39. 定位new运算符：

    ![image-20201208184519464](assets/image-20201208184519464.png)
  
  ```cpp
  #include <new>
  
  struct test {
      char chs[20];
      int i;
  };
  
  char buffer1[50];
  char buffer2[500];
  
  int main() {
      test *t1, *t2;
      int *p1, *p2;
      // 常规的new
      t1 = new test;      // 将test对象存入堆中
      p1 = new int[20];   // 将int数组对象存入堆中
  
      // 使用定位new
      t2 = new(buffer1) test;     // 将test对象存入buffer1中
      p2 = new(buffer2) int[20];  // 将int数组对象存入buffer2中
  }
  ```
  
  上面例子中使用两个静态数组buffer1和buffer2来为定位new运算符提供内存空间。所以从buffer1中分配空间给结构test，从buffer2中分配空间给一个包含20个元素的int数组。
  
  看一段实际的程序demo：
  
  ```cpp
  #include <new>
  
  const int BUF = 512;
  const int N = 3;
  char buffer[BUF];
  
  int main() {
      double *pd1, *pd2;
      pd1 = new double[N];
      pd2 = new(buffer) double[N];
      for (int i = 0; i < N; i++)
          pd1[i] = pd2[i] = 1000 * i;
  
      cout << "pd1:" << endl;
      for (int i = 0; i < N; i++)
          cout << pd1[i] << " at " << &pd1[i] << endl;
    	// 输出：
    	// pd1:
  		// 0 at 0x7f87b0c059a0
  		// 1000 at 0x7f87b0c059a8
  		// 2000 at 0x7f87b0c059b0
  
      cout << "pd2:" << endl;
      for (int i = 0; i < N; i++)
          cout << pd2[i] << " at " << &pd2[i] << endl;
    	// 输出：
  		// pd2:
  		// 0 at 0x102ae50f0
  		// 1000 at 0x102ae50f8
  		// 2000 at 0x102ae5100
  
      double *pd3, *pd4;
      pd3 = new double[N];
      pd4 = new(buffer) double[N];
      for (int i = 0; i < N; i++)
          pd3[i] = pd4[i] = 1000 * i;
  
      cout << "pd3:" << endl;
      for (int i = 0; i < N; i++)
          cout << pd3[i] << " at " << &pd3[i] << endl;
  		// 输出：
  		// pd3:
  		// 0 at 0x7f87b0c05a60
  		// 1000 at 0x7f87b0c05a68
  		// 2000 at 0x7f87b0c05a70
      cout << "pd4:" << endl;
      for (int i = 0; i < N; i++)
          cout << pd4[i] << " at " << &pd4[i] << endl;
    	// 输出：
  		// pd4:
  		// 0 at 0x102ae50f0
  		// 1000 at 0x102ae50f8
  		// 2000 at 0x102ae5100
    	// 注：地址与d2完全相同
  
      delete[]pd1;
      pd1 = new double[N];
      pd2 = new(buffer + N * sizeof(double)) double[N];
      for (int i = 0; i < N; i++)
          pd1[i] = pd2[i] = 1000 * i + 1;
  
      cout << "pd1:" << endl;
      for (int i = 0; i < N; i++)
          cout << pd1[i] << " at " << &pd1[i] << endl;
      // 输出：
  		// pd1:
  		// 1 at 0x7f87b0c059a0
  		// 1001 at 0x7f87b0c059a8
  		// 2001 at 0x7f87b0c059b0
      cout << "pd2:" << endl;
      for (int i = 0; i < N; i++)
          cout << pd2[i] << " at " << &pd2[i] << endl;
    	// 输出
    	// pd2:
  		// 1 at 0x102ae5108
  		// 1001 at 0x102ae5110
  		// 2001 at 0x102ae5118
    	// 注：地址都是接着pd4
    	delete[]pd1;
      delete[]pd3;
  }
  ```
  
  

